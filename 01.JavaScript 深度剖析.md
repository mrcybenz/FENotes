[TOC]

# ECMAScript 新特性

## JavaScript vs. ECMAScript
## 块级作用域、模板字符串
## 对象与数组的解构、rest 操作符
## 函数进阶（箭头函数、默认参数）
## 对象和数组的扩展用法
## Proxy、Reflect、Map、Set、Symbol
## for...of、迭代器模式、生成器函数
## ES Modules 模块系统
## ES2016 - ES2020（ES7 - ES11）特性一览
## 新特性编译工具（Babel）的使用
## 新特性的 Polyfill：CoreJS 标准库

# JavaScript 异步编程

## JavaScript 的单线程设计
## 同步模式和异步模式的调用差异
## 回调函数的执行原理
## Promise 异步方案的使用进阶与剖析
## 处理异步任务的任务队列和事件循环
## JavaScript 内部的宏任务与微任务
> 宏任务 setTimeout setInterval  
> 微任务 Promise MutationObserver  

## ES 6 Generator 迭代器的异步应用
## 使用 Async / Await 语法糖编写扁平的异步代码
  
# TypeScript 高级编程

## 编程语言的几种不同类型系统
## JavaScript 自有类型系统的问题
## Flow 静态类型检查方案
## Flow 工具的配置及相关插件的使用
## TypeScript 基本语法
## TypeScript 高级特性（泛型、接口）
## TypeScript 内置对象标准库
## TypeScript 的类型声明

# 函数式编程范式

## 函数式编程的本质以及应用场景
## 如何以函数式编程风格创建应用程序
## 用简单的代码构建复杂的应用程序
## 纯函数的定义以及为什么使用纯函数
## 为什么消除和控制副作用如此重要
## 柯里化、compose、高阶函数的优点
> lodash 源码中 memoize 实现的小感悟：  
> resolver.apply(this, args) 而非 resolver(...args) 是为了保持函数被包裹前后的 this 一致  

> 柯里化可以对函数的参数做缓存  
> 函数组合的写法约定俗成是从右到左  

> lodash 中的 map 方法，数据优先，迭代器置后，其迭代器参数接受三个参数  
> lodash/fp 中的 map 方法，迭代器优先，数据置后，并且是curried  
```js {cmd="node"}
const fp = require('lodash/fp')
const f = fp.flowRight(fp.join('-'), fp.map(fp.toLower), fp.split(' '))
console.log(f('NEVER SAY DIE'))
```

## 不可变的数据结构
## 常见库（Lodash、Ramda.js）

# JavaScript 性能优化

## JavaScript 中的垃圾收集
## JavaScript 内存管理
## V8 垃圾回收机制分类
## 引用计数、标记清除、标记整理和增量标记
## Preformance 工具的使用及注意事项
## 20 个代码层面的优化细节
