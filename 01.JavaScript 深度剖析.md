[TOC]

# ECMAScript 新特性

## JavaScript vs. ECMAScript
* ES 是语言，JS 是语言加宿主环境提供的接口(浏览器宿主提供了BOM、DOM，NodeJS宿主提供了fs、net)

## 块级作用域、模板字符串
* 块级作用域不存在类型提升
* 模板字符串 ${} 中可以放任何 JS 表达式
* 带标签的模板字符串，没什么用

## 对象与数组的解构、rest 操作符
* 数组按索引解构，用 = 添加默认值
* 对象用新对象解构：{ 匹配被解构对象的属性: 将匹配到的属性值存放该变量名 }, 用 = 添加默认值
* 

## 函数进阶（箭头函数、默认参数）
* 带有默认参数的函数变量应放在最后
* ... 操作符可以用作剩余操作符 跟 展开操作符
* 箭头函数中的 this 绑定定义处的 this

## 对象和数组的扩展用法
* 对象属性的 key value 相等可只写一个
* 对象方法可省略: function
* 支持计算属性，即允许将表达式的结果作为对象的属性
* Object.assign() 的返回值就是第一个参数
* Object.is
```js {cmd=node}
console.log(NaN === NaN);
console.log(Object.is(NaN, NaN));
console.log(+0 === -0);
console.log(Object.is(+0, -0));
```

## Proxy、Reflect、Map、Set、Symbol
*  Proxy 对比 Object.defineProperty()
> Proxy 能够监视到更多对象操作：get set has deleteProperty
> Proxy 对数组的监视更友好：对数组的 push 等操作可以在 set handler 中监视到
> Proxy 监管对象的方式是非侵入的，Object.defineProperty() 则需要重新定义对象的属性
* Reflect 是一个静态类，其内部的方法就是 Proxy handler 对象中方法的默认实现
* Reflect 作用在于提供了一套统一的 API 用以操作对象
```js {cmd=node}
const obj = {
    foo: 123,
    bar: 456,
};
const proxy = new Proxy(obj, {
    // 该 handler 对象方法成员的默认值是一个返回 Reflect 中对应方法的函数
    // 在函数中处理完业务逻辑之后，标准做法是返回 Reflect 中对应的方法
    get(target, property) {
        console.log('logic');
        return Reflect.get(target, property);
    }
});
console.log(proxy.foo);

console.log('name' in obj);
console.log(delete obj['age']);
console.log(Object.keys(obj));
// after
console.log(Reflect.has(obj, 'name'));
console.log(Reflect.deleteProperty(obj, 'age'));
console.log(Reflect.ownKeys(obj));
// Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。
// 它的返回值等同于Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。
```
## for...of、迭代器模式、生成器函数
## ES Modules 模块系统
## ES2016 - ES2020（ES7 - ES11）特性一览
## 新特性编译工具（Babel）的使用
## 新特性的 Polyfill：CoreJS 标准库

# JavaScript 异步编程

## JavaScript 的单线程设计
## 同步模式和异步模式的调用差异
## 回调函数的执行原理
## Promise 异步方案的使用进阶与剖析
## 处理异步任务的任务队列和事件循环
## JavaScript 内部的宏任务与微任务
> 宏任务 setTimeout setInterval
> 微任务 Promise MutationObserver

## ES 6 Generator 迭代器的异步应用
## 使用 Async / Await 语法糖编写扁平的异步代码
  
# TypeScript 高级编程

## 编程语言的几种不同类型系统
## JavaScript 自有类型系统的问题
## Flow 静态类型检查方案
## Flow 工具的配置及相关插件的使用
## TypeScript 基本语法
## TypeScript 高级特性（泛型、接口）
## TypeScript 内置对象标准库
## TypeScript 的类型声明

# 函数式编程范式

## 函数式编程的本质以及应用场景
## 如何以函数式编程风格创建应用程序
## 用简单的代码构建复杂的应用程序
## 纯函数的定义以及为什么使用纯函数
## 为什么消除和控制副作用如此重要
## 柯里化、compose、高阶函数的优点
> lodash 源码中 memoize 实现的小感悟：
> resolver.apply(this, args) 而非 resolver(...args) 是为了保持函数被包裹前后的 this 一致

> 柯里化可以对函数的参数做缓存
> 函数组合的写法约定俗成是从右到左

> lodash 中的 map 方法，数据优先，迭代器置后，其迭代器参数接受三个参数
> lodash/fp 中的 map 方法，迭代器优先，数据置后，并且是curried
```js {cmd="node"}
const fp = require('lodash/fp')
const f = fp.flowRight(fp.join('-'), fp.map(fp.toLower), fp.split(' '))
console.log(f('NEVER SAY DIE'))
```

## 不可变的数据结构
## 常见库（Lodash、Ramda.js）

# JavaScript 性能优化

## JavaScript 中的垃圾收集
## JavaScript 内存管理
## V8 垃圾回收机制分类
## 引用计数、标记清除、标记整理和增量标记
## Preformance 工具的使用及注意事项
## 20 个代码层面的优化细节
