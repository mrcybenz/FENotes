[TOC]

# ECMAScript 新特性

## JavaScript vs. ECMAScript
* ES 是语言，JS 是语言加宿主环境提供的接口(浏览器宿主提供了BOM、DOM，NodeJS宿主提供了fs、net)

## 块级作用域、模板字符串
* 块级作用域不存在类型提升
* 模板字符串 ${} 中可以放任何 JS 表达式
* 带标签的模板字符串，没什么用

## 对象与数组的解构、rest 操作符
* 数组按索引解构，用 = 添加默认值
* 对象用新对象解构：{ 匹配被解构对象的属性: 将匹配到的属性值存放该变量名 }, 用 = 添加默认值
* 

## 函数进阶（箭头函数、默认参数）
* 带有默认参数的函数变量应放在最后
* ... 操作符可以用作剩余操作符 跟 展开操作符
* 箭头函数中的 this 绑定定义处的 this

## 对象和数组的扩展用法
* 对象属性的 key value 相等可只写一个
* 对象方法可省略: function
* 支持计算属性，即允许将表达式的结果作为对象的属性
* Object.assign() 的返回值就是第一个参数
* Object.is
```js {cmd=node}
console.log(NaN === NaN);
console.log(Object.is(NaN, NaN));
console.log(+0 === -0);
console.log(Object.is(+0, -0));
```

## Proxy、Reflect、Map、Set、Symbol
*  Proxy 对比 Object.defineProperty()
> Proxy 能够监视到更多对象操作：get set has deleteProperty
> Proxy 对数组的监视更友好：对数组的 push 等操作可以在 set handler 中监视到
> Proxy 监管对象的方式是非侵入的，Object.defineProperty() 则需要重新定义对象的属性
* Reflect 是一个静态类，其内部的方法就是 Proxy handler 对象中方法的默认实现
* Reflect 作用在于提供了一套统一的 API 用以操作对象
```js {cmd=node}
const obj = {
    foo: 123,
    bar: 456,
};
const proxy = new Proxy(obj, {
    // 该 handler 对象方法成员的默认值是一个返回 Reflect 中对应方法的函数
    // 在函数中处理完业务逻辑之后，标准做法是返回 Reflect 中对应的方法
    get(target, property) {
        console.log('logic');
        return Reflect.get(target, property);
    }
});
console.log(proxy.foo);

console.log('name' in obj);
console.log(delete obj['age']);
console.log(Object.keys(obj));
// after
console.log(Reflect.has(obj, 'name'));
console.log(Reflect.deleteProperty(obj, 'age'));
console.log(Reflect.ownKeys(obj));
// Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。
// 它的返回值等同于Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。
```
* ...可以展开set
* 对象与 Map 的区别：对象只能使用字符串作为键，Map 可以将任意类型作为键
* Symbol 避免对象属性名重复的问题
* Symbol() 描述文本相同返回的结果不同，Symbol.for()则不同
* Symbol内部有一些常量，用作统一接口名称的键：toStringTag、iterator
```js {cmd=node}
const obj = {
    [Symbol()]: 'symbol key',
    foo: 'string key',
}
console.log(Object.getOwnPropertySymbols(obj)); // 拿 Symbol 属性
console.log(Object.getOwnPropertyNames(obj));   // 拿 字符串 属性
```

## 类 继承 静态成员
* super 指代父类对象

## for...of、迭代器模式、生成器函数
* for of 可以被 break 打断
* for of 可以遍历所有实现迭代器接口的类型
```js {cmd=node}
const todos = {
    [Symbol.iterator]: function() {
        const all = ['a', 'b', 'c'];
        let index = 0;
        return {
            next: function() {
                return {
                    value: all[index++],
                    done: index > all.length,
                }
            }
        }
    }
}
for(let value of todos) {
    console.log(value);
}
```
* 生成器函数，执行返回迭代器，然后调用 next 执行
```js {cmd=node}
function * idMaker() { // 生成器函数的简单用法
    let id = 1;
    while(true) {
        yield id++;
    }
}
const idMakerIt = idMaker();
console.log(idMakerIt.next());
console.log(idMakerIt.next());
console.log(idMakerIt.next());

const todos = { // 生成器函数已经实现了迭代器接口，所以用其实现更简洁
    [Symbol.iterator]: function * () {
        const all = ['a', 'b', 'c'];
        for(let item of all) {
            yield item;
        }
    }
}
for(let value of todos) {
    console.log(value);
}
```
## ES Modules 模块系统
## ES2016 - ES2020（ES7 - ES11）特性一览
* Array.prototype.includes();
* 指数运算 2 ** 10
* Object.values() Object.entries()
* Object.getOwnPropertyDescriptors() 用来拿到拥有getter setter 属性的对象的完整描述
* String.prototype.padStart() String.prototype.padEnd()
* 函数参数支持尾逗号
* Async / Await

## 新特性编译工具（Babel）的使用
## 新特性的 Polyfill：CoreJS 标准库

# JavaScript 异步编程

## JavaScript 的单线程设计
## 同步模式和异步模式的调用差异
## 回调函数的执行原理
## Promise 异步方案的使用进阶与剖析
## 处理异步任务的任务队列和事件循环
## JavaScript 内部的宏任务与微任务
> 宏任务 setTimeout setInterval
> 微任务 Promise MutationObserver

## ES 6 Generator 迭代器的异步应用
## 使用 Async / Await 语法糖编写扁平的异步代码
  
# TypeScript 高级编程

## 编程语言的几种不同类型系统
> 强类型与弱类型是**类型安全**的维度，判断依据是**变量的值**是否可以隐式转换
> 静态类型与动态类型是**类型检查**的维度，判断依据是**变量的类型**是否可以在运行时修改

## JavaScript 自有类型系统的问题
> 弱类型 动态类型
> 强类型语言的优势：在编译阶段更早更多地发现问题，使得IDE能够智能提示，减少不必要的类型判断

## Flow 静态类型检查方案
> 安装flow-bin -> // @flow -> npx flow init -> npx flow -> 查看校验结果
> 移除类型注解的方法：flow-remove-types | @babel/core @babel/cli @babel/preset-flow

## Flow 工具的配置及相关插件的使用
> flow 支持多种编辑器插件，需要保存后再做类型检查

## TypeScript 基本语法
## TypeScript 高级特性（泛型、接口）
## TypeScript 内置对象标准库
## TypeScript 的类型声明

# 函数式编程范式

## 函数式编程的本质以及应用场景
## 如何以函数式编程风格创建应用程序
## 用简单的代码构建复杂的应用程序
## 纯函数的定义以及为什么使用纯函数
## 为什么消除和控制副作用如此重要
## 柯里化、compose、高阶函数的优点
> lodash 源码中 memoize 实现的小感悟：
> resolver.apply(this, args) 而非 resolver(...args) 是为了保持函数被包裹前后的 this 一致

> 柯里化可以对函数的参数做缓存
> 函数组合的写法约定俗成是从右到左

> lodash 中的 map 方法，数据优先，迭代器置后，其迭代器参数接受三个参数
> lodash/fp 中的 map 方法，迭代器优先，数据置后，并且是curried
```js {cmd="node"}
const fp = require('lodash/fp')
const f = fp.flowRight(fp.join('-'), fp.map(fp.toLower), fp.split(' '))
console.log(f('NEVER SAY DIE'))
```

## 不可变的数据结构
## 常见库（Lodash、Ramda.js）

# JavaScript 性能优化

## JavaScript 中的垃圾收集
## JavaScript 内存管理
## V8 垃圾回收机制分类
## 引用计数、标记清除、标记整理和增量标记
## Preformance 工具的使用及注意事项
## 20 个代码层面的优化细节
